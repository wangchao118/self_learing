面向对象是当前软件开发方法的主流,其概念和应用早已超越了程序设计和软件开发的范围.

图形界面是典型的OO思想

1 封装

2 抽象

抽象的过程是对具体问题进行概括的过程,是对一类公共问题进行统一

3 继承

子类对象拥有与其基类相同的全部属性和方法,称为继承

4 多态

多态是指在基类中定义的属性和行为被子类继承后,可以具有不同的数据类型或者表现行为等特性.

假如动物是一个基类,它的子类有老虎,兔子,狗,小鸟,,,,,

那么作为动物有一个行为定义为Move(),那么这些子类继承下来后会根据自己的特性采取不同个性的Move()方式.



using namespace std;

这条指令带给我们一个全新的概念:命名空间

就是C++标准库所使用的所有标识符(即类 函数 对象等的名称)都是在同一个特殊的名字空间(std)中来定义的.


cin>>i; cin输入操作符又称为提取操作符,它一次从输入流对象cin提取一个整数.
当用户进行键盘操作时,对应的字符将输入到操作系统的键盘缓冲区中,
这样,当用户点击键盘上的"Enter"键时,操作系统把键盘缓冲区的内容传输到cin流的内部缓冲区,">>"操作符随后从这个缓冲区提取需要的信息.

argc 与argv[]
在程序中,main函数有两个参数,整型变量argc和字符指针数组argv[].
argc的含义是程序的参数数量,包含其本身
argv[]的每个指针指向命令行的一个字符串



函数的重载
所谓的函数重载的实质就是用同样的名字再定义一个有着不同参数但有着同样用途的函数.
可以是参数个数的不同,也可以是参数类型的不同


P8 复杂的数据类型-指针

变量的地址在程序执行期间是不会发生变化的
指针变量内存的就是地址

int *p;
int pp=123;
p = &pp;    pp变量的地址给了指针变量p

在创建指针不时,空格放在哪里都没有关系,指针变量前面的类型是用来说明指针指向的数据的类型,需要匹配使用.

P9
创建变量时,系统将分配一些内存用来保存它们的值;
每个内存拥有一个独一无二的地址
变量的地址可以用&variablename语法获取  &为取地址符
可以把地址赋值给一个称为指针的变量;
指针的类型必须与由他保存其地址的变量的类型一致

注意点:
1 指针所保存的是内存中的一个地址,它并不保存指向数据的值本身,因此,务必确定指针对应一个已经存在的变量或者一块已经分配了的内存
2 星号 * 有两种用途
(1) 第一种是用于创建指针:
int *myPointer = &mgInt;
(2) 第二种是对指针进行解引用:
*myPointer = 3998;
(3)c++允许多个指针有相同的值
   int *p1 = &myInt;
   int *p2 = &myInt;
(4)c++支持无类型(void)指针,就是没有被声明为某种特定类型的指针
  void *vPointer;

P10
数组名相当与其第一个元素的指针
int *ptr1 = &myArray[0];
int *ptr2 = myArray;

数组的基地址用指针变量保存,想访问其他元素 intPtr++  实际上是 +sizeof(int)


P11
结构与指针
创建一个指向该结构的指针:
FishOil *pJiayu = &Jiayu;
因为指针的类型必须与指向的地址的变量的类型一致,所以pJiayu指针的类型也是FishOil;

我们可以通过对指针进行解引用来访问相应的变量值
(*pJiayu).name = '黑夜'
或
pJiayu -> name = '黑夜';
pJiayu -> id = 'fishc_0001';


P12
被传递到函数的只是变量的值,永远不会是变量本身.

P13
类型别名 typedef int* intPointer



const限定符

如果程序在多个地方使用同一个常量,则需要修改该常量时,只需要修改一个符号定义即可

const int Months = 12;

创建常量的通用格式如下

const type name = value; 应在声明常量时对const进行初始化

const比#define的有点在于:

(1)能明确指定类型

(2)可以使用c++的作用域规则将定义限制在特定的函数或文件中

(3)可以将const用于更加复杂的类型




P14
绕开"值传递"问题的第一种方法是向函数传递变量的地址取代它的值,想要获取某个变量的地址只要在它前边加一个取地址操作符(&)就行了

引用传递


















